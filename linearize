#!/usr/bin/env python2

import sys
import argparse
from collections import defaultdict
from subprocess import Popen, PIPE

from reportlab.lib.pagesizes import letter
from reportlab.platypus import SimpleDocTemplate, Paragraph, Image, PageBreak
from reportlab.lib.units import inch

from reportlab.pdfgen import canvas

def main():

    #Enumerate the command line arguments, to automate argument parsing.
    parser = argparse.ArgumentParser(description='Imports a list of scanned pages into a gradable, sorted PDF.')
    parser.add_argument('--output', '-o',  metavar='output_pdf', default='assessment.pdf', help='The filename of the PDF to be produced')
    parser.add_argument('--suffix', '-s',  metavar='page_suffix', default=None, help='An image to be appended to the end of each question instance.')
    parser.add_argument('images', nargs='+' , metavar='image_files', help='A list of image files to include in the grading PDF.')
    
    #Parse the command line arguments.
    args = parser.parse_args()

    #let the user know that we're starting
    img_count = str(len(args.images))
    print("Beginning parse of " + img_count + " images.")

    pages = []

    #convert each of the speicifed files into a Page object
    for num, img in enumerate(args.images):

        #inform the user of the current progress (note the flush, which forces the functino to update in realtime)
        sys.stdout.write("Parsing image " + str(num) + " of " + str(img_count) + ".\r")
        sys.stdout.flush()

        #and then parse the image
        pages.append(Page.create_from_image(img))

    #if we've gotten a list of valid pages, in order
    if pages:
        assessment = Assessment.from_pages(pages)
        assessment.to_pdf(args.output, args.suffix)



class Assessment:
    """
    """


    def __init__(self, questions):

        #initialize an empty dictionary-of-lists
        self.questions = questions

    @classmethod
    def from_pages(cls, pages):

        questions = defaultdict(dict)

        #for each of the pages
        for page in pages:

            #if the page starts a response
            if isinstance(page, QuestionPage):

                #get the core identifying information regarding the given page
                identifier = page.get_identifier()

                #get a reference to the collection of attempts for the given question
                question_attempts = questions[identifier.question_id]

                #and create a new list of pages, starting with this response
                question_attempts[identifier.question_attempt_id] = [ page ]

                #TODO: handle extension pages
        

        return cls(questions)

    def to_pdf(self, filename, suffix=None):
        """
        """

        width = 8.5*inch
        height = 780 + 159
        doc = SimpleDocTemplate(filename, pagesize=(width, height), rightMargin=0, leftMargin=0, topMargin=0, bottomMargin=0)


        images = []

        for attempts in self.questions.values():

            for pages in attempts.values():

                for page in pages:

                    page_image = Image(page.image_path, 600, 780)
                    images.append(page_image)


                    if suffix is not None:
                        page_image = Image(suffix, 600, 146)
                        images.append(page_image)
        
        doc.build(images)




class Page:
    """
        Data for a single scanned page from an assessment.
    """

    image_path = None
    """ The filename of the images which hold the student work for this question. """

    identifiers = None
    """ A list of barcode objects found on the given page. """

    def __init__(self, filename, identifiers):
        """
            Create a new Page object from its member fields.
        """
        self.image_path = filename
        self.identifiers = identifiers


    def is_first_page(self):
        """
            Returns True iff this page is the first page of a student response.
        """

        #if this page contains a question identifier, then it must be the start page of a response 
        return any(isinstance(i, QuestionIdentifier) for i in self.identifiers)


    @classmethod
    def create_from_image(cls, filename):
        """
            Creates a new page object given the image present.
        """

        #extract each of the barcodes from the image
        barcodes = cls.get_barcodes_from_image(filename)

        #and convert any non-empty result to an identifier object
        identifiers = [Identifier.from_barcode(barcode) for barcode in barcodes if barcode]

        #if this page contains a Question ID, it is a page that starts a question
        if any(isinstance(i, QuestionIdentifier) for i in identifiers):
            return QuestionPage(filename, identifiers)

        #otherwise, it's an extension page
        else:
            return ExtensionPage(filename, identifiers)


        
        #create a new Page object given the images
        return cls(filename, identifiers)

    @staticmethod
    def get_barcodes_from_image(filename):
        """
            Parses a given image, and returns a list of identified barcodes.
            TODO: Replace with zbar python module? 
        """

        #use zbar to read the barcode data
        barcodes = Popen('./extractcodes "' + filename + '"', stdout=PIPE, shell=True).stdout.read()

        #and return the identified barcodes.
        return barcodes.split("\n")

class QuestionPage(Page):

    def get_identifier(self):
        """
            Returns the question number for the given page.
        """

        #iterate over the identifiers until we find a QuestionIdentifier
        for i in self.identifiers:
            if isinstance(i, QuestionIdentifier):

                #and return that question's ID
                return i


    def extension_id(self):
        """
            Returns the extension ID for the given page, if one exists.
        """

        #iterate over the identifiers until we find a QuestionIdentifier
        for i in self.identifiers:
            if isinstance(i, ExtensionIdentifier):

                #and return that question's ID
                return i






class ExtensionPage(Page):
    pass

class Identifier(object):

    @classmethod
    def from_barcode(cls, barcode):

        #for each of the known identifiers
        for sub in cls.__subclasses__():

            #if the identifier is the correct handler for a given barcode type
            if sub.is_wrapper_for(barcode):

                #return a new instance of that barcode
                return sub.from_barcode(barcode)

        #otherwise, return none
        return None

    @staticmethod
    def is_wrapper_for(barcode):
        """
            Indicates if the given Identifier handles a particualr barcode type.
        """
        return False;


class QuestionIdentifier(Identifier):
    """
        Stores the data for a single question page.
    """

    usage_id = None
    """ The Moodle Question Usage, which is the unique ID number for a given quiz attempt. """

    question_id = None
    """ The Moodle Question ID, which uniquely identifies the _question_, but which is shared among all attempts at this quesiton variation."""

    question_attempt_id = None
    """ The Moodle Question Attempt ID, which uniquely identifies the student's attempt at the given question. """

    def __init__(self, usage, question, question_attempt):

        #set each piece of question information
        self.usage_id = int(usage)
        self.question_id = int(question)
        self.question_attempt_id = int(question_attempt)
        
    @staticmethod
    def is_wrapper_for(barcode):
        #if the data starts with a digit, it's a normal page
        return barcode and barcode[0].isdigit() and "|" in barcode


    @classmethod
    def from_barcode(cls, barcode):

       #split the data into its its three integer parts
       usage, question, question_attempt = [int(i) for i in barcode.split('|')]

       #and use them to create a new
       return cls(usage, question, question_attempt)

class ExtensionIdentifier(Identifier):
    
    @staticmethod
    def is_wrapper_for(barcode):
        #TODO
        return False




#run the main function if this file was called directly
if __name__ == "__main__":
    main()
