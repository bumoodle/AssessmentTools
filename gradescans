#!/usr/bin/env ruby

require 'zbar'
require 'RMagick'
require 'highline/import'


# Extend the ZBar module to include better handling of Color images.
module ZBar
  class Image

    # Creates a ZBar Image from a JPEG image; enhanced for recognizing Black-and-White
    # barcodes in color JPEG images. 
    #
    # @param [String, File] image The image file to be wrapped with a ZBar Image object.
    # @param [Float] image The "darkness" threshold a pixel must meet to be considered black. Pixels which 
    #                      do not meed this threshold are considered white.
    # 
    # @return [Image] The ZBar Image object that wraps the given image.
    #
    def self.from_color_jpeg(image, threshold=0.65)
   
        #if we were passed readable object (e.g. a file)
        #read its contents before continuing
        if image.respond_to?(:read)
            image = image.read
        end

        #convert the image into an ImageMagick object
        image = Magick::Image::from_blob(image).first

        #convert the image into black-and-white using a mid-range threshold
        image = image.threshold(Magick::QuantumRange * threshold)

        #and remove the ImageMagick wrapper
        image = image.to_blob
        
        #wrap the converted
        self.from_jpeg(image)
    end
  
  end
end

# TODO: Replace with real TermView module
#
# Temporary stand-in for a TermView module, which re-implements the perl application 'tiv' 
# in Ruby.
module TermView
 
  # Prints the given image such that it can be interpreted on the command line.
  def self.show_image(image, start=1010)

    #get the directory in which this script file resides
    local_dir = File::expand_path(File::dirname(__FILE__))

    #and call the termview stand-in from the same directory
    system("\"#{local_dir}/termview\" -s #{start} \"#{image}\"")

  end

end

#Represents a paper version of a Moodle quesion attempt.
class QuestionAttempt

  #Regular expression used to parse Question Identifier codes
  QUESTION_ID = /([0-9]+)\|([0-9]+)\|([0-9]+)/

  #Regular expression usd to parse Grade Disqualifier codes
  GRADE_DISQUALIFIER = /GRADE([0-9]+)/

  #allow the grade to be read/written externally
  attr_accessor :grade

  #allow the identifiers to be read/written externally
  attr_accessor :usage_id
  attr_accessor :question_id
  attr_accessor :attempt_id

  # Initializes a new Question Attempt object.
  def initialize(usage_id, question_id, attempt_id, images, grade = 0)
    
    #import values from the constructor
    @usage_id = usage_id
    @question_id = question_id
    @attempt_id = attempt_id
    @images = images
    @grade = grade

  end

  # Returns the proper Moodle-uploadable filename for then given Question Attempt.
  #
  # @param [Integer] page The page number to be appended to the filename.
  # @param [String] extension The extension to be appended to the filename, including the leading dot, or nil to use the same filetype as the original image.
  def filename_for_upload(page=0, extension=nil, directory=nil)
    
    #get the original filename used to represent the QA
    original_filename = @images[page] 

    #if the extension has not already been set, use the extension from the original filename
    extension ||= File::extname(original_filename)

    #if the directory has not already been set, use the same directory as the original file
    directory ||= File::dirname(original_filename)

    #return the new filename
    "#{directory}/U#{@usage_id}_Q#{@question_id}_A#{@attempt_id}_G#{@grade}_P#{page}#{extension}"
  end

  def rename_for_upload!(extension=nil)

    #rename each of the images in the Question Attempt
    @images.each_with_index { |image, i| File::rename(image, filename_for_upload(i)) }

  end

  def missing_identifiers?
    @usage_id.nil? or @question_id.nil? or @attempt_id.nil?
  end

  # Creates a new QuestionAttempt object from a set of images.
  #
  # @param [Array, string] A filename, or list of filenames, which contain images to be parsed as question attempts.
  #
  def self.from_images(images, threshold=0.65)
   
    #initialize the QA's identifiers to nil
    usage_id, question_id, attempt_id = nil, nil, nil

    #and create a list of possible grades
    possible_grades = *(1..10)

    #If we haven't been provided a collection of images, wrap the image in an Array
    images = *[images] unless images.respond_to?(:each)

    #process each image in our array
    images.each do |raw_image|

      #ZBar::Image.from_jpeg(File.read(image)).process
      image = ZBar::Image.from_color_jpeg(File.read(raw_image), threshold)

      #extract the barcodes from the image
      barcodes = image.process

      #process each of the extracted barcodes
      barcodes.each do |code|
      
        #attempt to match the barcode against our Question ID pattern
        data = code.data.match(QUESTION_ID)
        
        #if it matches the identifier pattern
        if data

          #use it to determine the QA's identifiers
          usage_id, question_id, attempt_id = data[1], data[2], data[3]
          
        end

        #attempt ot match the barcode against our grade disqualifier pattern
        data = code.data.match(GRADE_DISQUALIFIER)

        #if the data matches the disqualifier pattern
        if data
 
          #get the value of the grade that was disqualified
          grade = Integer(data[1])

          #and remove the disqualified grade from the array of possible grades
          possible_grades.delete(grade)

        end
      end

      #if we were able to find a grade, then use it; otherwise, set a grade of nil
      grade = (possible_grades.count == 1) ? possible_grades[0] : nil

      #Create a new QuestionAttempt object from the parsed data 
      return self.new(usage_id, question_id, attempt_id, images, grade) 

    end
  end
end

def interactive_mass_rename!

  #inform the user that we're about to start
  print "Grading and renaming #{ARGV.count} files.\n"

  #store a list of grades encountered so far
  grades = []

  #for each of the provided image files
  ARGV.each do |image|

    #parse the image into a Question Attempt
    qa = QuestionAttempt.from_images(image)

    #if the question's grade is nil
    if qa.grade.nil?

      print "\n"
      STDOUT.flush

      #display the grading information for the image on the command line
      TermView::show_image(image)

      #get a grade from the user between 0 and 10
      qa.grade = ask("\nCouldn't find a grade in the image above ('#{image}'). Enter an integer grade between 0 and 10> ", Integer) { |i| i.in = 0..10 }

    end

    #if the question is missing identifiers, prompt for them on the command line
    if qa.missing_identifiers?

      #establish the format in which the user should enter the identifier 
      identifier_format = /^([0-9]+)-([0-9]+)-([0-9]+)$/

      p qa

      #prompt the user for the question's identifier
      identifier = ask ("\nCouldn't figure out the Attempt ID for '#{image}'. Enter the attempt ID displayed below the question barcode> ")  { |i| i.validate = identifier_format }

      #once we have a valid identifier, parse it, and extract the user's information
      identifier = identifier.match(identifier_format)
      
      #and use it to fill in the missing fields from the QA
      qa.usage_id, qa.question_id, qa.attempt_id = identifier[1], identifier[2], identifier[3]

    end

    #rename the file, applying a format accepted by Moodle
    qa.rename_for_upload!

    #add the question's grade to the local array of grades
    grades << qa.grade

    #compute a quick average of the grades encountered
    average = (grades.inject(0.0) { | sum, element | sum + element }) / grades.count

    #and print a quick status update.
    print "Renamed #{grades.count} files. Average grade #{average.round(2)}.               \r"
    STDOUT.flush

  end
end

#TODO: accept modes other than rename
interactive_mass_rename!
